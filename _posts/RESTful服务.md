---
title: RESTful服务
date: 2016-07-26 11:58:16
categories: 互联网
tags: RESTful
---
## 什么是 REST
REST 代表表述性状态转移（representational state transfer），它是一种网络化超媒体应用的架构风格。它主要是用于构建轻量级的、可维护的、可伸缩的 Web 服务。基于 REST 的服务被称为 RESTful 服务。REST 不依赖于任何协议，但是几乎每个 RESTful 服务使用 HTTP 作为底层协议。
RESTful 使用HTTP post（创建、更新）数据、读取数据、删除数据。使用HTTP实现CRUD（创建、读取、更新、删除）操作

<!--more-->
## RESTful 服务特点
每个系统都使用资源。这些资源可以是图片，视频文件，网页，商业信息，或者在基于计算机的系统中可以被代表的任何事物。服务的目的是提供一个窗口给客户端以便客户端能访问这些资源。服务架构师和开发人员想要这些服务变得易于实现、维护、扩展、伸缩。RESTful 架构允许这些，甚至更多。一般来说，RESTful 服务应该有下面的属性和特征
- 模型表示（Representations）
- 消息（Messages）
- URIs
- 一致接口（Uniform interface）
- （无状态）Stateless
- 资源之间的链接（Links between resources）
- 缓存（Caching）

## 模型表示
RESTful 服务的焦点在资源上和怎么提供对资源的访问。资源很容易被认为和OOP中的对象一样。一个资源能由其他资源组成。当设计一个系统的时候，第一件要做的事情是定义资源和决定资源之间的关系。这有点像设计数据库的第一步。定义实体和关系。
 
一旦我们定义了资源，接下来我们需要找到一种用于在系统中表示这些资源的方法。你可以使用任何格式来表示资源。REST 对此没有限制。
 
例如，根据你的需求，你可以决定使用 JSON 。如果你在构建 Web 服务，此服务用于 Web 页面中的 AJAX 调用，那 JSON 是很好地选择。例如一个被称为“Person”的资源可以表示如下：
### 资源的JSON 表示
```
{
    "ID": "1",
    "Name": "hello",
    "Email": "hello@qq.com",
    "Country": "China"
}
```

## 消息
客户端和服务端经由消息相互沟通。客户端发送请求到服务器，服务器使用响应答复。除了实际的数据，这些信息也包含一些关于消息的元数据。对于设计 RESTful 服务了解 HTTP 1.1的请求格式和响应格式是很重要的。

## HTTP 请求
### HTTP 请求格式
<VERB> GET, PUT, POST, DELETE, OPTIONS等等 HTTP 方法的一种。 
<URI> 资源的URI。操作将在这个 URI 上执行。 
<HTTP Version> HTTP 版本，通常是“HTTP v1.1”。 
<Request Header> 包含 header 键值对集合的元数据。这些设置包含消息的信息和发送者像客户端的类型，客户端支持的格式，消息体的格式类型，响应的缓存设置，和许多信息。
<Request Body> 是实际的消息内容。在 RESTful 服务中，这就是消息中资源表示的位置。
在 HTML 消息中没有标签和标识标记区块的开始或结束。
列表三是简单的 POST 请求消息，这个请求想要插入一条新的 Person 资源

## 资源定位
REST 要求每个资源至少有一个 URI。 RESTful 服务使用人类可读的URIs层级目录来定位资源。URI 要做的工作是定义一个资源或资源集合。实际的操作由 HTTP 动作决定。URI 应该没有任何关于处理和动作的内容。这使我们能够调用相同的 URI 使用不同的 HTTP 动词来执行不同的操作。
 
对于构建良好的 URIs 这有些重要的推荐：

使用复数名词命名你的资源。
避免使用制造混乱的空格。使用_或者-代替。
URI 不区分大小写。为了更清晰我使用驼峰写法。你也可以使用全部小写的URIs。
你也能够有你自己的约定，但是要在整个服务保持一致。确保你的客户端都知道这个约定。你的客户端 URIs 程序构建将更简单如果它们知道你遵循的资源层级和URI约定。
好的 URI 是不会变更的。再决定服务的 URIs 之前要先思考思考。如果你需要改变资源的定位，不要放弃老的 URI。如果请求来自老的 URI，使用状态码300重定向客户端到新的location。
避免使用动词命名你的资源直到你的资源是一个实际地操作或过程。动词更加适合操作的命名。例如，RESTful 服务不应该有 http://Service/FetcthPerson/1 或 http://Service/DeletePerson?id=1 类似的 URI。

### GET
```
安全且幂等
获取表示
变更时获取表示（缓存）
200（OK） - 表示已在响应中发出
204（无内容） - 资源有空表示
301（Moved Permanently） - 资源的URI已被更新
303（See Other） - 其他（如，负载均衡）
304（not modified）- 资源未更改（缓存）
400 （bad request）- 指代坏请求（如，参数错误）
404 （not found）- 资源不存在
406 （not acceptable）- 服务端不支持所需表示
500 （internal server error）- 通用错误响应
503 （Service Unavailable）- 服务端当前无法处理请求
```

### POST
```
不安全且不幂等
使用服务端管理的（自动产生）的实例号创建资源
创建子资源
部分更新资源
如果没有被修改，则不过更新资源（乐观锁）
200（OK）- 如果现有资源已被更改
201（created）- 如果新资源被创建
202（accepted）- 已接受处理请求但尚未完成（异步处理）
301（Moved Permanently）- 资源的URI被更新
303（See Other）- 其他（如，负载均衡）
400（bad request）- 指代坏请求
404 （not found）- 资源不存在
406 （not acceptable）- 服务端不支持所需表示
409 （conflict）- 通用冲突
412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）
415 （unsupported media type）- 接受到的表示不受支持
500 （internal server error）- 通用错误响应
503 （Service Unavailable）- 服务当前无法处理请求
```

### PUT
```
不安全但幂等
用客户端管理的实例号创建一个资源
通过替换的方式更新资源
如果未被修改，则更新资源（乐观锁）
200 （OK）- 如果已存在资源被更改
201 （created）- 如果新资源被创建
301（Moved Permanently）- 资源的URI已更改
303 （See Other）- 其他（如，负载均衡）
400 （bad request）- 指代坏请求
404 （not found）- 资源不存在
406 （not acceptable）- 服务端不支持所需表示
409 （conflict）- 通用冲突
412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）
415 （unsupported media type）- 接受到的表示不受支持
500 （internal server error）- 通用错误响应
503 （Service Unavailable）- 服务当前无法处理请求
```

### DELETE
```
不安全但幂等
删除资源
200 （OK）- 资源已被删除
301 （Moved Permanently）- 资源的URI已更改
303 （See Other）- 其他，如负载均衡
400 （bad request）- 指代坏请求
404 （not found）- 资源不存在
409 （conflict）- 通用冲突
500 （internal server error）- 通用错误响应
503 （Service Unavailable）- 服务端当前无法处理请求
```

### 常见问题
#### POST和PUT用于创建资源时有什么区别?
```
POST和PUT在创建资源的区别在于，所创建的资源的名称(URI)是否由客户端决定。 例如为我的博文增加一个java的分类，生成的路径就是分类名/categories/java，那么就可以采用PUT方法。不过很多人直接把POST、GET、PUT、DELETE直接对应上CRUD，例如在一个典型的rails实现的RESTful应用中就是这么做的。
我认为，这是因为rails默认使用服务端生成的ID作为URI的缘故，而不少人就是通过rails实践REST的，所以很容易造成这种误解。
```

#### 统一资源接口对URI有什么指导意义?
```
统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作。
一切事物都是资源，资源是没有版本号的。版本号是 API 的概念
```

## 状态的转移
无状态通信原则，并不是说客户端应用不能有状态，而是指服务端不应该保存客户端状态,
RESTful只要维护资源的状态，而不需要维护客户端的状态。对于它来说，每次请求都是全新的，它只需要针对本次请求作相应的操作，不需要将本次请求的相关信息记录下来以便用于后续来自相同客户端请求的处理

###  应用状态与资源状态
状态应该区分应用状态和资源状态，客户端负责维护应用状态，而服务端维护资源状态。
客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。
服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。
这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。
在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。
但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。
这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。
当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。
